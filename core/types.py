"""
Core data structures and types for the Wick Reversal Strategy.
"""

from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, List, Dict, Any
from enum import Enum
import uuid


class Side(Enum):
    """Trade direction."""
    LONG = "long"
    SHORT = "short"


class OrderType(Enum):
    """Order types."""
    MARKET = "market"
    LIMIT = "limit"
    STOP_MARKET = "stop_market"
    TAKE_PROFIT = "take_profit"


class OrderStatus(Enum):
    """Order execution status."""
    PENDING = "pending"
    OPEN = "open"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"


class PositionStatus(Enum):
    """Position lifecycle status."""
    PENDING_ENTRY = "pending_entry"
    OPEN = "open"
    PENDING_EXIT = "pending_exit"
    CLOSED = "closed"


class SignalType(Enum):
    """Signal classification."""
    UPPER_WICK_SHORT = "upper_wick_short"
    LOWER_WICK_LONG = "lower_wick_long"
    NO_SIGNAL = "no_signal"


class FilterResult(Enum):
    """Market filter outcomes."""
    PASSED = "passed"
    VOLUME_SPIKE = "volume_spike"
    ATR_EXPANSION = "atr_expansion"
    BTC_MOVE = "btc_move"
    LOW_VOLUME = "low_volume"
    HIGH_SPREAD = "high_spread"
    THIN_ORDERBOOK = "thin_orderbook"
    TIME_FILTER = "time_filter"
    COOLDOWN = "cooldown"


@dataclass
class Candle:
    """OHLCV candlestick data."""
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: float
    
    # Computed properties
    @property
    def body_size(self) -> float:
        """Absolute size of candle body."""
        return abs(self.close - self.open)
    
    @property
    def upper_wick(self) -> float:
        """Size of upper wick."""
        return self.high - max(self.open, self.close)
    
    @property
    def lower_wick(self) -> float:
        """Size of lower wick."""
        return min(self.open, self.close) - self.low
    
    @property
    def is_bullish(self) -> bool:
        """True if close > open."""
        return self.close > self.open
    
    @property
    def range(self) -> float:
        """Total high-low range."""
        return self.high - self.low
    
    @property
    def midpoint(self) -> float:
        """Midpoint of the candle range."""
        return (self.high + self.low) / 2
    
    @property
    def body_midpoint(self) -> float:
        """Midpoint of the candle body."""
        return (self.open + self.close) / 2
    
    def wick_to_body_ratio(self, wick_type: str = "upper") -> float:
        """Calculate wick to body ratio."""
        body = self.body_size
        if body == 0:
            return float('inf')  # Doji candle
        wick = self.upper_wick if wick_type == "upper" else self.lower_wick
        return wick / body
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "open": self.open,
            "high": self.high,
            "low": self.low,
            "close": self.close,
            "volume": self.volume,
            "body_size": self.body_size,
            "upper_wick": self.upper_wick,
            "lower_wick": self.lower_wick,
        }


@dataclass
class MarketData:
    """Aggregated market data snapshot."""
    symbol: str
    timestamp: datetime
    candle: Candle
    
    # Technical indicators
    atr: float
    vwap: float
    
    # Volume metrics
    volume_sma: float
    volume_ratio: float  # Current / SMA
    
    # Volatility metrics
    atr_baseline: float
    atr_ratio: float  # Current / Baseline
    
    # Order book data (optional)
    bid_price: Optional[float] = None
    ask_price: Optional[float] = None
    spread: Optional[float] = None
    bid_depth_usd: Optional[float] = None
    ask_depth_usd: Optional[float] = None
    
    # BTC reference (for correlation filter)
    btc_price: Optional[float] = None
    btc_change_pct: Optional[float] = None


@dataclass
class Signal:
    """Trading signal generated by signal detection."""
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:8])
    timestamp: datetime = field(default_factory=datetime.utcnow)
    symbol: str = ""
    signal_type: SignalType = SignalType.NO_SIGNAL
    
    # Signal strength and confidence
    strength: float = 0.0  # 0-1 scale
    
    # Candle that generated the signal
    trigger_candle: Optional[Candle] = None
    
    # Signal detection criteria met
    criteria_met: List[str] = field(default_factory=list)
    
    # Suggested entry/exit levels
    suggested_entry: Optional[float] = None
    suggested_stop: Optional[float] = None
    suggested_target: Optional[float] = None
    
    # Market context
    atr: float = 0.0
    vwap: float = 0.0
    
    # Filter status
    filter_result: FilterResult = FilterResult.PASSED
    filter_details: str = ""
    
    @property
    def side(self) -> Optional[Side]:
        """Get trade side from signal type."""
        if self.signal_type == SignalType.UPPER_WICK_SHORT:
            return Side.SHORT
        elif self.signal_type == SignalType.LOWER_WICK_LONG:
            return Side.LONG
        return None
    
    @property
    def is_valid(self) -> bool:
        """Check if signal is actionable."""
        return (
            self.signal_type != SignalType.NO_SIGNAL
            and self.filter_result == FilterResult.PASSED
            and self.strength > 0
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary for logging."""
        return {
            "id": self.id,
            "timestamp": self.timestamp.isoformat(),
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "strength": self.strength,
            "criteria_met": self.criteria_met,
            "suggested_entry": self.suggested_entry,
            "suggested_stop": self.suggested_stop,
            "suggested_target": self.suggested_target,
            "filter_result": self.filter_result.value,
            "is_valid": self.is_valid,
        }


@dataclass
class Order:
    """Order representation."""
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])
    symbol: str = ""
    side: Side = Side.LONG
    order_type: OrderType = OrderType.LIMIT
    
    # Quantities
    quantity: float = 0.0
    filled_quantity: float = 0.0
    
    # Prices
    price: Optional[float] = None  # For limit orders
    stop_price: Optional[float] = None  # For stop orders
    average_fill_price: Optional[float] = None
    
    # Status
    status: OrderStatus = OrderStatus.PENDING
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    
    # Execution details
    commission: float = 0.0
    slippage: float = 0.0
    
    # Linking
    signal_id: Optional[str] = None
    position_id: Optional[str] = None
    
    # Exchange order ID
    exchange_order_id: Optional[str] = None
    
    @property
    def is_filled(self) -> bool:
        return self.status == OrderStatus.FILLED
    
    @property
    def fill_pct(self) -> float:
        if self.quantity == 0:
            return 0.0
        return self.filled_quantity / self.quantity
    
    def to_dict(self) -> dict:
        """Convert to dictionary for logging."""
        return {
            "id": self.id,
            "symbol": self.symbol,
            "side": self.side.value,
            "order_type": self.order_type.value,
            "quantity": self.quantity,
            "filled_quantity": self.filled_quantity,
            "price": self.price,
            "average_fill_price": self.average_fill_price,
            "status": self.status.value,
            "commission": self.commission,
            "slippage": self.slippage,
        }


@dataclass
class Position:
    """Active position representation."""
    id: str = field(default_factory=lambda: str(uuid.uuid4())[:12])
    symbol: str = ""
    side: Side = Side.LONG
    status: PositionStatus = PositionStatus.PENDING_ENTRY
    
    # Position sizing
    quantity: float = 0.0
    entry_price: float = 0.0
    
    # Risk levels
    stop_loss: float = 0.0
    take_profit: float = 0.0
    
    # Calculated at entry
    risk_amount: float = 0.0
    risk_reward_ratio: float = 0.0
    
    # P&L tracking
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    
    # Timestamps
    opened_at: Optional[datetime] = None
    closed_at: Optional[datetime] = None
    
    # Candle tracking (for time-based exits)
    entry_candle_count: int = 0
    current_candle_count: int = 0
    
    # Trailing stop
    trailing_stop_active: bool = False
    trailing_stop_price: Optional[float] = None
    highest_price: Optional[float] = None  # For shorts: lowest
    
    # Related objects
    signal_id: Optional[str] = None
    entry_order_ids: List[str] = field(default_factory=list)
    exit_order_ids: List[str] = field(default_factory=list)

    # Exchange-based stop/TP order IDs (for real-time protection)
    stop_order_id: Optional[str] = None
    take_profit_order_id: Optional[str] = None

    # Partial take profit tracking
    partial_tp_order_id: Optional[str] = None
    partial_tp_price: Optional[float] = None
    partial_tp_quantity: float = 0.0
    partial_tp_taken: bool = False
    original_quantity: float = 0.0  # Store original size before partial exit

    # Commission tracking
    total_commission: float = 0.0
    
    @property
    def is_open(self) -> bool:
        return self.status == PositionStatus.OPEN
    
    @property
    def candles_held(self) -> int:
        return self.current_candle_count - self.entry_candle_count
    
    @property
    def net_pnl(self) -> float:
        """Net P&L after commissions."""
        return self.realized_pnl + self.unrealized_pnl - self.total_commission
    
    def update_unrealized_pnl(self, current_price: float):
        """Update unrealized P&L based on current price."""
        if self.side == Side.LONG:
            self.unrealized_pnl = (current_price - self.entry_price) * self.quantity
        else:
            self.unrealized_pnl = (self.entry_price - current_price) * self.quantity
    
    def update_trailing_stop(self, current_price: float, atr: float, config):
        """Update trailing stop if conditions met."""
        if not self.trailing_stop_active:
            # Check if we should activate trailing stop
            if self.side == Side.LONG:
                pnl_pct = (current_price - self.entry_price) / self.entry_price
                target_pct = (self.take_profit - self.entry_price) / self.entry_price
            else:
                pnl_pct = (self.entry_price - current_price) / self.entry_price
                target_pct = (self.entry_price - self.take_profit) / self.entry_price
            
            if pnl_pct >= target_pct * config.trailing_stop_activation:
                self.trailing_stop_active = True
                self.highest_price = current_price
        
        if self.trailing_stop_active:
            trail_distance = atr * config.trailing_stop_distance_atr
            
            if self.side == Side.LONG:
                if current_price > (self.highest_price or current_price):
                    self.highest_price = current_price
                self.trailing_stop_price = self.highest_price - trail_distance
            else:
                if self.highest_price is None or current_price < self.highest_price:
                    self.highest_price = current_price
                self.trailing_stop_price = self.highest_price + trail_distance
    
    def to_dict(self) -> dict:
        """Convert to dictionary for logging."""
        return {
            "id": self.id,
            "symbol": self.symbol,
            "side": self.side.value,
            "status": self.status.value,
            "quantity": self.quantity,
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "unrealized_pnl": self.unrealized_pnl,
            "realized_pnl": self.realized_pnl,
            "net_pnl": self.net_pnl,
            "candles_held": self.candles_held,
            "trailing_stop_active": self.trailing_stop_active,
            "trailing_stop_price": self.trailing_stop_price,
        }


@dataclass
class TradeResult:
    """Completed trade record for analysis."""
    position_id: str
    symbol: str
    side: Side

    # Entry details
    entry_price: float
    entry_time: datetime

    # Exit details
    exit_price: float
    exit_time: datetime
    exit_reason: str  # "take_profit", "stop_loss", "trailing_stop", "time_exit", "manual"

    # Position details
    quantity: float

    # P&L
    gross_pnl: float
    commission: float
    net_pnl: float
    pnl_pct: float

    # Risk metrics
    risk_amount: float
    reward_risk_ratio: float

    # Duration
    candles_held: int
    duration_seconds: int

    # Signal info
    signal_strength: float
    signal_criteria: List[str]

    # Market context at entry
    atr_at_entry: float
    vwap_at_entry: float

    # Extended analysis fields
    entry_hour: int = 0  # Hour of day (0-23 UTC)
    entry_day_of_week: int = 0  # Day of week (0=Monday, 6=Sunday)
    leverage_multiplier: float = 1.0  # Dynamic leverage multiplier applied
    num_criteria_met: int = 0  # Count of criteria met
    has_wtb_ratio: bool = False  # Wick-to-body ratio criterion met
    has_atr_ratio: bool = False  # ATR ratio criterion met
    has_vwap_dist: bool = False  # VWAP distance criterion met
    atr_ratio_at_entry: float = 0.0  # ATR / baseline ATR (volatility regime)
    volume_ratio_at_entry: float = 0.0  # Volume / baseline volume
    price_vs_vwap_pct: float = 0.0  # How far price was from VWAP (%)
    wick_size_pct: float = 0.0  # Wick size as % of price

    @property
    def is_winner(self) -> bool:
        return self.net_pnl > 0

    def to_dict(self) -> dict:
        """Convert to dictionary for analysis."""
        return {
            "position_id": self.position_id,
            "symbol": self.symbol,
            "side": self.side.value,
            "entry_price": self.entry_price,
            "entry_time": self.entry_time.isoformat() if self.entry_time else None,
            "exit_price": self.exit_price,
            "exit_time": self.exit_time.isoformat() if self.exit_time else None,
            "exit_reason": self.exit_reason,
            "quantity": self.quantity,
            "gross_pnl": self.gross_pnl,
            "commission": self.commission,
            "net_pnl": self.net_pnl,
            "pnl_pct": self.pnl_pct,
            "risk_amount": self.risk_amount,
            "reward_risk_ratio": self.reward_risk_ratio,
            "candles_held": self.candles_held,
            "duration_seconds": self.duration_seconds,
            "signal_strength": self.signal_strength,
            "signal_criteria": self.signal_criteria,
            "atr_at_entry": self.atr_at_entry,
            "vwap_at_entry": self.vwap_at_entry,
            # Extended analysis fields
            "entry_hour": self.entry_hour,
            "entry_day_of_week": self.entry_day_of_week,
            "leverage_multiplier": self.leverage_multiplier,
            "num_criteria_met": self.num_criteria_met,
            "has_wtb_ratio": self.has_wtb_ratio,
            "has_atr_ratio": self.has_atr_ratio,
            "has_vwap_dist": self.has_vwap_dist,
            "atr_ratio_at_entry": self.atr_ratio_at_entry,
            "volume_ratio_at_entry": self.volume_ratio_at_entry,
            "price_vs_vwap_pct": self.price_vs_vwap_pct,
            "wick_size_pct": self.wick_size_pct,
            "is_winner": self.is_winner,
        }


@dataclass 
class AccountState:
    """Current account state."""
    timestamp: datetime = field(default_factory=datetime.utcnow)
    
    # Balances
    total_equity: float = 0.0
    available_balance: float = 0.0
    margin_used: float = 0.0
    
    # Performance tracking
    starting_equity: float = 0.0
    peak_equity: float = 0.0
    daily_starting_equity: float = 0.0
    
    # Drawdown
    current_drawdown: float = 0.0
    max_drawdown: float = 0.0
    
    # Daily P&L
    daily_pnl: float = 0.0
    daily_trades: int = 0
    
    # Position summary
    open_positions: int = 0
    total_exposure: float = 0.0
    
    # Trade statistics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    
    @property
    def win_rate(self) -> float:
        if self.total_trades == 0:
            return 0.0
        return self.winning_trades / self.total_trades
    
    def update_drawdown(self):
        """Update drawdown calculations."""
        if self.total_equity > self.peak_equity:
            self.peak_equity = self.total_equity
        
        if self.peak_equity > 0:
            self.current_drawdown = (self.peak_equity - self.total_equity) / self.peak_equity
            self.max_drawdown = max(self.max_drawdown, self.current_drawdown)
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "timestamp": self.timestamp.isoformat(),
            "total_equity": self.total_equity,
            "available_balance": self.available_balance,
            "current_drawdown": self.current_drawdown,
            "max_drawdown": self.max_drawdown,
            "daily_pnl": self.daily_pnl,
            "open_positions": self.open_positions,
            "win_rate": self.win_rate,
        }
